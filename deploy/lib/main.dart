import "dart:isolate" as bE;import "dart:html" as j;import "dart:collection" as DC;import "dart:math" as VB;class TE{final  name;const TE(this.name);}abstract class bB{var tB;var description;var canvas;var context;bB(this.tB,this.description,this.canvas,this.context);update( g);yB( g);}class UE extends bB{var GB;var TB;var UB;final  AE=360/60;final  RC=360/60;final  zD=360/12;UE( g, h):super("Analog Clock","A simple clock generated entirely with paths.",g,h){this.GB=VB.min(g.width,g.height)*0.49;this.TB=g.width/2;this.UB=g.height/2;} update( g){} yB( aB){final  i=new DateTime.now();context.save();context.clearRect(0,0,canvas.width,canvas.height);context.lineWidth=3;context.beginPath();context.arc(canvas.width/2,canvas.height/2,GB,0,VB.PI*2,false);context.closePath();context.setFillColorRgb(255,255,255,1);context.fill();for(int h=0;h<60;h++ ){context.save();var g;if(h%15==0){g=30;}else if(h%5==0){g=20;}else{g=10;}var l=RC*h;var o=QC(l);var q=WC(l);var CB=(GB*o);var w=(GB*q);var AB=((GB-g)*o);var PB=((GB-g)*q);context.translate(TB,UB);context.beginPath();context.moveTo(AB,PB);context.lineTo(CB,w);context.closePath();context.setStrokeColorRgb(0,0,0,1);context.stroke();context.restore();}uB((zD*i.hour),GB-50,0,0,255);uB((RC*i.minute),GB-20,255,0,0);uB((AE*i.second),GB,0,255,0);context.beginPath();context.arc(canvas.width/2,canvas.height/2,GB,0,VB.PI*2,false);context.closePath();context.setStrokeColorRgb(0,0,0,1);context.stroke();context.restore();} uB( g, h, w, l, o){context.save();context.translate(TB,UB);context.rotate((3*VB.PI)/2);context.translate(-TB,-UB);var CB=QC(g);var AB=WC(g);var i=((h*CB)+TB);var q=((h*AB)+UB);context.beginPath();context.moveTo(TB,UB);context.lineTo(i,q);context.closePath();context.setStrokeColorRgb(w,l,o,1);context.stroke();context.restore();} QC( g){return VB.cos(g*(VB.PI/180));} WC( g){return VB.sin(g*(VB.PI/180));}}class jB{var x,y,red,green,blue;var MB,gB,multiplier,alpha;jB(this.x,this.y,this.MB,this.gB,[this.red=255,this.green=255,this.blue=255,this.alpha=1.0,this.multiplier=1.0]);}var kB;var lB;class aC{var fB;var canvas;var context;var elements;var CE;var BE;aC(){canvas=j.query('#gCanvas');canvas.width=canvas.clientWidth;canvas.height=canvas.clientHeight;fB=new HB(canvas);context=canvas.context2D;fB.start();elements=new Map<String,bB>();var g;g=new VE(canvas,context);elements[g.tB]=g;g=new UE(canvas,context);elements[g.tB]=g;} ME( g){CE=g;BE=elements[g].description;context.setTransform(1,0,0,1,0,0);fB.xB=elements[g].update;fB.wB=elements[g].yB;}} main(){kB=new aC();lB=mD(new List<String>());kB.elements.keys.forEach((g)=>lB.add(g));kB.ME(lB.last);}class VE extends bB{final  iB=new VB.Random();var hB;VE( g, h,[ maxRings=100]):super("Rings","A particle system example.",g,h){FE((VB.sqrt(VB.pow(g.width,2)+VB.pow(g.height,2))/2).floor());} FE( o){hB=new List<jB>(o);var g,h;var w,l,CB;var AB=(canvas.width*.1).round();var q=(canvas.height*.1).round();for(int i=0;i<o;i++ ){g=iB.nextInt(canvas.width-(AB*2))+AB;h=iB.nextInt(canvas.height-(q*2))+q;l=[g,h,canvas.width-g,canvas.height-h].reduce(VB.min).toDouble();w=iB.nextDouble()*l;CB=(iB.nextDouble()*2.0)+0.5;hB[i]=new jB(g,h,w,l,255,255,255,1.0,CB);}} update( h){for(jB g in hB){g.MB+= g.multiplier;if(g.multiplier>0){if(g.MB>g.gB){g.MB=g.gB;g.multiplier*= -1.0;}}else{if(g.MB<1){g.MB=1.0;g.multiplier*= -1.0;}}}} yB( i){context.clearRect(0,0,canvas.width,canvas.height);for(jB g in hB){var h=g.MB/g.gB;g.alpha=h;context.beginPath();context.arc(g.x,g.y,g.MB,0,VB.PI*2,false);context.closePath();context.setStrokeColorRgb(g.red,g.green,g.blue,g.alpha);context.stroke();}}}abstract class EC{ get x; get y; get dx; get dy; get time; get p;}class FC{final  XB;var TC=0;var UC=0;var NE=0.0;var OE=0.0;FC(this.XB); get YB=>TC>UC;}typedef  bC( gameLoop);abstract class DB{var ZB=0.015;var vB=0.03; get p; get VC; get DE=>ZB;static  mB(g)=>g/1000.0; get time=>mB(new DateTime.now().millisecondsSinceEpoch);DB(){} JE(){var fE=gE.length;for(int g=0;g<fE;g++ ){gE[g].hE(DE);}for(int g=gE.length-1;g>=0;g-- ){var h=gE.length-1;if(gE[g].iE){if(g!=h){gE[g]=gE[h];}gE.removeLast();}}} start();final  gE=new List<cC>();var xB;}class cC{cC();}class dC{dC();}class GC{final  YB;final  p;final  XB;final  time;GC(this.XB,this.YB,this.p,this.time); toString()=>'Button: ${XB} DOWN: ${YB} [${p}@${time}]';}class nB{final  n;final  buttons=new Map<int,FC>();nB(this.n, h){for(int g in h){buttons[g]=new FC(g);}} SC( h){var g=buttons[h.XB];if(g==null){return;}if(h.YB){if(g.YB==false){g.TC=h.p;g.NE=h.time;}}else{g.UC=h.p;g.OE=h.time;}}}class fC{final  x;final  y;final  dx;final  dy;final  rB;final  sB;final  time;final  zB;final  p;fC(this.x,this.y,this.dx,this.dy,this.rB,this.sB,this.zB,this.time,this.p);}class eC{final  n;eC(this.n){n.element.onClick.listen(jE);j.document.onPointerLockChange.listen(kE);} KE(){n.element.requestPointerLock();} jE( g){if(GE){KE();}}var GE=true; kE( g){if(n.onPointerLockChange!=null){n.onPointerLockChange(n);}}}class JB{static const HC=0x1;static const IC=0x2;static const JC=0x3;final  event;final  type;JB(this.event,this.type);}class gC{final  n;var buttons;var aE;gC(this.n){}}typedef  hC( gameLoop);class iC extends nB{static const jC=j.KeyCode.A;static const lC=j.KeyCode.B;static const mC=j.KeyCode.C;static const nC=j.KeyCode.D;static const pC=j.KeyCode.E;static const qC=j.KeyCode.F;static const rC=j.KeyCode.G;static const tC=j.KeyCode.H;static const uC=j.KeyCode.I;static const wC=j.KeyCode.J;static const yC=j.KeyCode.K;static const AD=j.KeyCode.L;static const CD=j.KeyCode.M;static const ED=j.KeyCode.N;static const FD=j.KeyCode.O;static const GD=j.KeyCode.P;static const HD=j.KeyCode.Q;static const ID=j.KeyCode.R;static const JD=j.KeyCode.S;static const KD=j.KeyCode.T;static const LD=j.KeyCode.U;static const MD=j.KeyCode.V;static const ND=j.KeyCode.W;static const OD=j.KeyCode.X;static const PD=j.KeyCode.Y;static const QD=j.KeyCode.Z;static const RD=j.KeyCode.SHIFT;static const SD=j.KeyCode.CTRL;static const TD=j.KeyCode.ALT;static const UD=j.KeyCode.SPACE;static const VD=j.KeyCode.ZERO;static const WD=j.KeyCode.ONE;static const XD=j.KeyCode.TWO;static const YD=j.KeyCode.THREE;static const ZD=j.KeyCode.FOUR;static const aD=j.KeyCode.FIVE;static const bD=j.KeyCode.SIX;static const cD=j.KeyCode.SEVEN;static const dD=j.KeyCode.EIGHT;static const eD=j.KeyCode.NINE;static const fD=j.KeyCode.TILDE;static const gD=j.KeyCode.ENTER;static const hD=j.KeyCode.UP;static const iD=j.KeyCode.DOWN;static const vC=j.KeyCode.LEFT;static const zC=j.KeyCode.RIGHT;static final  BD=[jC,lC,mC,nC,pC,qC,rC,tC,uC,wC,yC,AD,CD,ED,FD,GD,HD,ID,JD,KD,LD,MD,ND,OD,PD,QD,RD,SD,TD,UD,VD,WD,XD,YD,ZD,aD,bD,cD,dD,eD,fD,gD,hD,iD,vC,zC];iC(g):super(g,BD);}typedef  kC( gameLoop);class KC implements EC{final  x;final  y;final  dx;final  dy;final  time;final  p;KC(this.x,this.y,this.dx,this.dy,this.time,this.p);}typedef  oC( gameLoop);typedef  sC( gameLoop);class LC extends nB implements EC{static const vC=0;static const xC=1;static const zC=2;static final  BD=[vC,xC,zC];var nE=0; get dx=>nE;var rE=0; get dy=>rE;var vE=0; get x=>vE;var wE=0; get y=>wE;var xE=0; get rB=>xE;var AF=0; get sB=>AF;var BF=0;var EF=0;var GF=false; get zB=>GF;var IF=0.0; get time=>IF;var KF=0; get p=>KF;LC(g):super(g,BD); EE( g){vE=g.x;wE=g.y;IF=g.time;KF=g.p;nE+= g.dx;rE+= g.dy;xE=g.rB;AF=g.sB;GF=g.zB;} PF( h, g){BF+= h;EF+= g;} RF(){BF=0;EF=0;nE=0;rE=0;}}typedef  MC( gameLoop, touch);class cB{final  id;final  IE=new List<KC>();cB(this.id);}class HB extends DB{final  element;var lE=0;var mE=false;var oE=false;var pE;var qE=0.0;var sE=false;var tE=0.0; get p=>lE;var vB=0.03;var yE=0.0; get width=>element.client.width; get height=>element.client.height;var CF=0.0; get VC=>CF;var DF=0.0;var LE=0.05;var HF;var JF;var LF; get HE=>LF;var MF;var OF;HB(this.element):super(){JF=new iC(this);LF=new LC(this);MF=new gC(this);HF=new eC(this);OF=new DD(this);} QF(){for(j.KeyboardEvent AC in SF){var h;var BC=AC.type=="keydown";var i=DB.mB(AC.timeStamp);var PB=AC.keyCode;h=new GC(PB,BC,p,i);JF.SC(h);}SF.clear();HE.RF();var AB=element.offset.left;var CB=element.offset.top;for(j.MouseEvent g in TF){var PE=g.type=='mousemove';var QE=g.type=='mousewheel';var BC=g.type=='mousedown';var i=DB.mB(g.timeStamp);if(PE){var CC=g.page.x;var aB=g.page.y;var XC=CC-AB;var YC=aB-CB;var q=0;var l=0;var o=false;if(CC<AB){q=0;}else if(CC>AB+width){q=width;}else{q=XC;o=true;}if(aB<CB){l=0;o=false;}else if(aB>CB+height){l=height;o=false;}else{l=YC;}var RE=g.movement.x;var SE=g.movement.y;var h=new fC(XC,YC,RE,SE,q,l,o,i,p);LF.EE(h);}else if(QE){var ZC=g as j.WheelEvent;LF.PF(ZC.deltaX,ZC.deltaY);}else{var PB=g.button;var h=new GC(PB,BC,p,i);LF.SC(h);}}TF.clear();for(JB w in UF){switch (w.type){case JB.JC:OF.zE(w.event);break;case JB.IC:OF.FF(w.event);break;case JB.HC:OF.NF(w.event);break;default:throw new StateError('Invalid _GameLoopTouchEven type.');}}UF.clear();}var VF; WF( XF){if(pE==null){qE=time;pE=qE;QF();VF=j.window.requestAnimationFrame(WF);return;}if(oE==true){VF=null;return;}VF=j.window.requestAnimationFrame(WF);lE++ ;pE=qE;qE=time;var g=qE-pE;yE+= g;if(yE>vB){yE=vB;}QF();while (yE>=ZB){JE();CF+= ZB;if(xB!=null){xB(this);}yE-= ZB;}if(sE==true&&onResize!=null&&tE<=qE){onResize(this);tE=qE+LE;sE=false;}if(wB!=null){DF=yE/ZB;wB(this);}} YF( XF){if(onFullscreenChange==null){return;}onFullscreenChange(this);} ZF( XF){if(onFullscreenChange==null){return;}onFullscreenChange(this);}final  UF=new List<JB>(); aF( g){UF.add(new JB(g,JB.JC));} bF( g){UF.add(new JB(g,JB.HC));} cF( g){UF.add(new JB(g,JB.IC));}final  SF=new List<j.KeyboardEvent>(); dF( g){SF.add(g);} eF( g){SF.add(g);}final  TF=new List<j.MouseEvent>(); fF( g){TF.add(g);} gF( g){TF.add(g);} hF( g){TF.add(g);} iF( g){TF.add(g);g.preventDefault();} jF( XF){if(sE==false){sE=true;}} start(){if(mE==false){j.document.onFullscreenError.listen(ZF);j.document.onFullscreenChange.listen(YF);j.window.onTouchStart.listen(aF);j.window.onTouchEnd.listen(cF);j.window.onTouchMove.listen(bF);j.window.onKeyDown.listen(dF);j.window.onKeyUp.listen(eF);j.window.onResize.listen(jF);j.window.onMouseMove.listen(hF);j.window.onMouseDown.listen(fF);j.window.onMouseUp.listen(gF);j.window.onMouseWheel.listen(iF);mE=true;}oE=false;VF=j.window.requestAnimationFrame(WF);}var wB;var onResize;var onFullscreenChange;var onPointerLockChange;var onTouchStart;var onTouchEnd;}class DD{final  eB=new Map<int,cB>();final  n;DD(this.n); uE( i, g){var h=new KC(g.client.x,g.client.y,0,0,n.VC,n.p);i.IE.add(h);} zE( i){i.changedTouches.forEach(( g){var h=new cB(g.identifier);eB[g.identifier]=h;uE(h,g);if(n.onTouchStart!=null){n.onTouchStart(n,h);}});} FF( i){i.changedTouches.forEach(( g){var h=eB[g.identifier];eB.remove(g.identifier);uE(h,g);if(n.onTouchEnd!=null){n.onTouchEnd(n,h);}});} NF( h){h.changedTouches.forEach(( g){var i=eB[g.identifier];uE(i,g);});}}class jD<KB> extends yD with IB implements List<KB>{final  kF;jD([ length]):kF=length!=null?new List<KB>(length):<KB>[] ;factory jD.cE( g)=>new jD<KB>()..addAll(g); get length{if(t)BB(this,k.s,'length');return kF.length;}set length( h){var i=kF.length;if(i==h)return;if(LB(this)){if(h<i){for(int g=i-1;g>=h;g-- ){m(this,k.NB,g,kF[g],null);}m(this,k.s,'length',i,h);}else{m(this,k.s,'length',i,h);for(int g=i;g<h;g++ ){m(this,k.RB,g,null,null);}}}kF.length=h;} operator[]( g){if(t)BB(this,k.EB,g);return kF[g];}operator[]=( g, h){var i=kF[g];if(LB(this)){m(this,k.EB,g,i,h);}kF[g]=h;} sublist( g,[ end])=>new jD<KB>.cE(super.sublist(g,end)); add( h){var g=kF.length;if(LB(this)){m(this,k.s,'length',g,g+1);m(this,k.RB,g,null,h);}kF.add(h);} toString(){if(t){for(int g=0;g<length;g++ ){BB(this,k.EB,g);}}return kF.toString();}}typedef  WB<u,v>();class QB<u,v> extends IB implements Map<u,v>{final  lF;var mF;var nF;QB({ createMap}):lF=createMap!=null?createMap():new Map<u,v>(){mF=new kD<u,v>(this);nF=new lD<u,v>(this);}factory QB.dE( i,{ createMap}){var g=new QB<u,v>(createMap:createMap);i.forEach(( h, l){g[h]=l;});return g;} get keys=>mF; get values=>nF; get length{if(t)BB(this,k.s,'length');return lF.length;} get isEmpty=>length==0; oF( g)=>BB(this,k.EB,g); pF(){BB(this,k.s,'length');lF.keys.forEach(oF);} containsKey( g){if(t)oF(g);return lF.containsKey(g);} operator[]( g){if(t)oF(g);return lF[g];} operator[]=( h, g){var l=lF.length;var i=lF[h];lF[h]=g;if(LB(this)){if(l!=lF.length){m(this,k.s,'length',l,lF.length);m(this,k.RB,h,i,g);}else if(i!=g){m(this,k.EB,h,i,g);}}} remove( g){if(t)oF(g);var h=lF.length;var i=lF.remove(g);if(LB(this)&&h!=lF.length){m(this,k.NB,g,i,null);m(this,k.s,'length',h,lF.length);}return i;} clear(){var g=lF.length;if(LB(this)&&g>0){lF.forEach((i,h){m(this,k.NB,i,h,null);});m(this,k.s,'length',g,0);}lF.clear();} forEach( g( key, value)){if(t)pF();lF.forEach(g);} toString()=>DC.Maps.mapToString(this);}class kD<u,v> extends DC.IterableBase<u>{final  lF;kD(this.lF); get iterator=>new WE<u,v>(lF);}class WE<u,v> implements Iterator<u>{final  lF;final  mF;var qF=false;WE( g):lF=g,mF=g.lF.keys.iterator; moveNext(){if(t)BB(lF,k.s,'length');return qF=mF.moveNext();} get current{var g=mF.current;if(t&&qF)lF.oF(g);return g;}}class lD<u,v> extends DC.IterableBase<v>{final  lF;lD(this.lF); get iterator=>new XE<u,v>(lF);}class XE<u,v> implements Iterator<v>{final  lF;final  mF;final  nF;var qF;XE( g):lF=g,mF=g.lF.keys.iterator,nF=g.lF.values.iterator; moveNext(){if(t)BB(lF,k.s,'length');var h=mF.moveNext();var g=nF.moveNext();if(h!=g){throw new StateError('keys and values should be the same length');}return qF=g;} get current{if(t&&qF)lF.oF(mF.current);return nF.current;}}class k{static const s=1;static const EB=2;static const RB=EB|4;static const NB=EB|8;final  type;final key;final oldValue;final newValue;k(this.type,this.key,this.oldValue,this.newValue); operator==(g){return g is k&&type==g.type&&key==g.key&&oldValue==g.oldValue&&newValue==g.newValue;} get hashCode=>vD(type,key,oldValue,newValue); toString(){var g;switch (type){case s:g='field';break;case EB:g='index';break;case RB:g='insert';break;case NB:g='remove';break;}return '#<ChangeRecord ${g} ${key} from ${oldValue} to ${newValue}>';}}mD(g){if(g is Map){var h=null;if(g is DC.SplayTreeMap){h=()=>new DC.SplayTreeMap();}else if(g is DC.LinkedHashMap){h=()=>new DC.LinkedHashMap();}return new QB.dE(g,createMap:h);}if(g is Set)return new PC.eE(g);if(g is Iterable)return new jD.cE(g);return g;}class IB{var qB;var SB;final  hashCode= ++IB.nD;static var nD=0;} LB( g)=>g.qB!=null&&g.qB.head!=null; get t=>NC!=null; BB( g, h,i)=>NC.rF(g,h,i); m( g, l,o, h, i){if((l&(k.RB|k.NB))==0){if(h==i)return;}if(OB==null){OB=[] ;wD(oD);}if(g.SB==null){g.SB=[] ;OB.add(g);}g.SB.add(new k(l,o,h,i));}var NC;var OC=100;var OB;var dB; oD(){var q=0;while (OB!=null||dB!=null){var l=OB;OB=null;var i=dB;dB=null;if(q++ ==OC){pD(l,i);return;}if(l!=null){for(var h in l){var AB=h.SB;h.SB=null;for(var g=h.qB.head;g!=null;g=g.next){var o=g.value;try {o(AB);}catch (CB,w){tD(CB,w,o,'from ${h}');}}}}if(i!=null){i.forEach((aB,PB){PB.sF();});}}} pD( o, l){var g=[] ;if(o!=null){for(var i in o){var AB=i.SB;g.add('${i} ${AB}');}}if(l!=null){for(var q in l.values){var h=q.sF();if(h!=null)g.add('${q} ${h}');}}OB=null;dB=null;var w='exceeded notifiction limit of ${OC}, possible ' 'circular reference in observer callbacks: ${g.take(10).join(", ")}';rD(w);}class oB{oB();}typedef  qD( message);var rD=(g)=>print(g);typedef  sD(error,stackTrace,obj, message);var tD=uD; uD(i,g,h, l){print('web_ui.observe: unhandled error calling ${h} ${l}.\n' 'error:\n${i}\n\nstack trace:\n${g}');}class PC<FB> extends xD with IB implements Set<FB>{final  tF;final  uF;PC({ createMap}):tF=createMap!=null?createMap():new Map<FB,Object>(),uF=createMap;factory PC.eE( g,{ createMap}){return new PC<FB>(createMap:createMap)..addAll(g);} add( g){var h=tF.length;tF[g]=const Object();if(h!=tF.length){m(this,k.s,'length',h,tF.length);m(this,k.RB,g,null,g);}} remove( g){if(t)BB(this,k.EB,g);var h=tF.length;tF.remove(g);if(h!=tF.length){if(LB(this)){m(this,k.NB,g,g,null);m(this,k.s,'length',h,tF.length);}return true;}return false;} clear(){if(LB(this)){for(var g in tF.keys){m(this,k.NB,g,g,null);}m(this,k.s,'length',tF.length,0);}tF.clear();} get length{if(t)BB(this,k.s,'length');return tF.length;} get isEmpty=>length==0; get iterator=>new YE<FB>(this); addAll( g)=>g.forEach(add); toString(){if(t){for(FB g in tF.keys){BB(this,k.EB,g);}}return tF.keys.toSet().toString();}}class YE<FB> implements Iterator<FB>{final  vF;final  wF;var xF=false;YE( g):vF=g,wF=g.tF.keys.iterator; moveNext(){vF.length;return xF=wF.moveNext();} get current{var g=wF.current;if(t&&xF)BB(vF,k.EB,g);return g;}}pB(h,g)=>h.hashCode*31+g.hashCode;vD(g,i,h,l)=>pB(pB(g,i),pB(h,l)); wD( h()){var g=new bE.ReceivePort();g.receive((i,l){g.close();h();});g.toSendPort().send(null);}abstract class xD extends DC.IterableBase<dynamic>{}abstract class yD extends DC.ListMixin<dynamic>{}